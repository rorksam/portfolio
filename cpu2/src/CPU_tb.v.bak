`include "Defs.vh"

`timescale 1ns/1ps  //  time delay/resolution

`define SIM_STEPS 30
`define RAM_RANGE 20


module CPU_tb();

// cpu wires
reg clk;
reg rst;
integer i;

CPU cpu(.clk(clk),.rst(rst)); 

// alt way to describe clock
//initial 
//begin
//	clk = 0; // need to init clk!
//   forever #(1) clk = ~clk; // Toggle clock every half period
//end
always #1 clk = ~clk;

initial 
begin
	clk = 0; // need to init clk!
	rst = 1;
	#2
	rst = 0;
	//////////////////
	// instruction mem
	//////////////////
	cpu.ram.mem[0] = {`ALU_OP_AND,10'd008,10'd009,10'd010};
	cpu.ram.mem[1] = {`ALU_OP_OR,10'd010,10'd011,10'd012};
	//////////////////
	// data mem
	//////////////////
	cpu.ram.mem[8]  = 32'b00000000_00000000_00000000_00000101;
	cpu.ram.mem[9]  = 32'b00000000_00000000_00000000_00000110;
	cpu.ram.mem[10] = 32'b00000000_00000000_00000000_00000000;
	cpu.ram.mem[11] = 32'b00000000_00000000_00000000_00000101;
	cpu.ram.mem[12] = 32'b00000000_00000000_00000000_00000000;
	
	// show memory before run
	$display("RAM before run:");
	for (i = 0; i < `RAM_RANGE; i = i+1) 
		$display("addr = %03d, data = %b", i, cpu.ram.mem[i]);
	
	#2
	$display("CPU in action");	
	for (i = 0; i < `SIM_STEPS; i = i+1) 
	begin
		#2;
		$display("addr = %d, dataIn = %d, dataOut = %d", cpu.addrW, cpu.dinW, cpu.doutW);
	end

	// show memory after run
	$display("RAM after run:");
	for (i = 0; i < `RAM_RANGE; i = i+1) 
		$display("addr = %03d, data = %b", i, cpu.ram.mem[i]);

	$stop;
  
end

endmodule